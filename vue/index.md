# vite打包优化
- vue如果明确知道项目不会使用某些特性，可以把特性关闭，较少vue体积，例如不是有options的api
- 动态导入，使用import(xxx)语法，打包的时候rollup会将该文件单独打成个一个包，页面使用的时候就可以动态加载，优化初始化加载时间
- 代码分割 可以手动的将某些模块打包在一起，如果不指定，所有没有分包出去的文件最终都会打包到主bundle中，导致包太大，加载太慢，可以手动指定某几个模块打包在一起，减少包体积。

# 命令式和声明式框架
```js
// 01 - 获取 id 为 app 的 div 标签
// 02 - 它的文本内容为 hello world
// 03 - 为其绑定点击事件
// 04 - 当点击时弹出提示：ok
命令式的实现
 $('#app') // 获取 div
.text('hello world') // 设置文本内容
.on('click', () => { alert('ok') }) // 绑定点击事件

声明式的实现
 <div @click="() => alert('ok')">hello world</div>
```
- 命令式更加关注**过程**，像jq，而声明式更加关注**结果**例如vue的模板
- vue帮我们封装了整个过程，但是内部最终还是使用命令式实现的

# 运行时和编译时的区别
- 纯运行时：提供一个render函数，然后根据入参（vnode对象）直接渲染成dom
- 运行时编译 提供一个compile函数，将html编译成vnode，然后调用render函数渲染dom
- 纯编译时 使用compile函数，将html直接编译成js代码进行dom的挂载




# vue2为什么不能使用下标修改数组，vue3可以
https://juejin.cn/post/7350585600859308084
-首先数组长度的完全不固定的，所以你无法在定义初期就给他设置defineProperty进行劫持，这个方案根本就是不可行的，其次数组数据量一多的话，给他们都做劫持是非常耗性能的，而且没有太多的必要。所以vue2选择重写数组的方法，来进行依赖的收集
- vue3的话使用proxy是可以劫持到未定义的索引值的设置，所以不需要$set这个api了，但是他也重写了数组的方法，主要是因为一些比如push、pop等方法的执行，首先会收集length这个依赖，然后又对他进行set，这会导致无限循环的问题，所以重写这些方法，在调用的时候阻止依赖的收集。那么该方法最终都会修改到数组的元素，所以都会走到set方法中，然后手动将与length相关的effect拿出来执行。
- vue3还重写一些includes等查找方法的原因是，当数组是如下格式的时候：arr=[{a:1}]，调用查找方法的时候，实际上是在代理对象中找数据，这样的话是找不到的，所以重写方法，主要思路就是现在代理对象中找，找不到再去原始对象中查找

# vue中slot插槽使用响应式数据，组件怎么更新的
```js
<Component>{{count}}</Component>

```
首次渲染的时候，count收集的effect是子组件，所以当父组件中的count值发生变化，自然触发的是子组件的更新，而不是整个父组件的更新


# vue中的keepalive
- 在第一次渲染的时候调用render函数，会在内部的缓存数据中查找，因为第一次是肯定找不到缓存的，所以还是会走基础的组件挂载流程，并且将vnode缓存到cash数据中
- 当第二次进入组件的时候，执行render函数，从cash中找到缓存的vnode，直接将缓存中的组件实例赋值给vnode，然后设置keepalive属性为true，这样当走到patch函数的时候，判断vnode的keepalive属性是true就不会走组件的mounte过程，而是直接走keepalive组件特有的activite函数，即直接将缓存的真实dom插入到页面中.
- ![alt text](<截屏2024-07-22 22.45.21.png>)
- ![alt text](<截屏2024-07-22 22.45.52.png>)
![alt text](<截屏2024-07-22 22.47.25.png>)


！！！但是vue3为什么要加入 创建隐藏容器的操作呢？？？？？