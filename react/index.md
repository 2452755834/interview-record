# 运行时和编译时的区别 AOT（构建时编译/预编译）和JIT（即时编译）的区别
- 运行时更像是命令式编程，类似vue提供的h函数，让我们直接生成对应的vnode
- 编译时更像是的声明式编程，内部也是调用命令式实现的。类似于我们直接写template，内部会转换为调用h函数的结果
- AOT是预先编译 像vue的template，在运行之前就可以根据模版进行编译，可以进行很多优化，对内容进行分析，区分静态内容和动态内容，而且可以做依赖的收集，这样后续更新只需要找到对应动态节点进行更新
- JIT是即时编译，也就是运行时编译，就像jsx，函数在执行之前永远不知道他返回的是什么东西，所以无法像AOT那样做静态编译的优化，所以react才需要fiber，因为他默认更新机制就是父组件更新，下面的子组件都需要全量更新，但是他也提供了很多方法，让开发者自己做优化，而vue就是在内部帮我们把优化做好了。

# 合成事件 16和17版本的区别
合成事件只是给元素加了onClick属性，实际的事件监听是放在根元素上，当事件冒泡到根元素，逐层去找到各个元素的onClick属性执行。  
 - 16中将合成事件委托到document上，17委托到root元素
 - 16只委托了冒泡阶段 17冒泡和捕获阶段都委托
 - 拿到的event是合成事件的event,e.nativeEvent才是真正的事件对象
 - 16版本问题 主要是如果页面上有多个react版本，事件都委托到document，那么stopPropagation无法阻止其他react中的事件冒泡因为已经都到达了document元素 

#  为什么react需要fiber&时间分片而vue没有
- react组件更新的时候，默认是全量更新，父组件一旦更新，所有子组件都要更新，所以diff阶段会花费很多时间，有大概率会造成页面卡顿，所以需要时间切片
- vue因为使用template模版，可以做静态分析，更新的时候只会更新需要的组件，所以diff的节点会比较少，用到切片的概率很小，作者认为vue没有太大必要引入时间切片，收益不大
- (https://github.com/vuejs/rfcs/issues/89)
#  组件渲染优化
 -  function组件可以使用react.memo进行缓存，如果props没变化组件不会重新渲染，类似于class组件的pureComponent，都是采用object.is来比较新老props
  
# createPortal与vue的teleport相似，可以将节点插入到任意为止