# vite面试题

## 什么是构建工具

背景：首先浏览器只认识html、css、js这些文件，但是我们在实际业务开发过程中可能是会使用到ts、vue、react等库，

- 比如ts，我们需要tsc转化为js文件
- vue我们需要vue-compiler将我们的vue代码转化为js函数
- scss的写法浏览器也是不认识的，需要进行sass-loader进行转化
- 语法降级：babel
- 代码体积优化：uglifyjs代码压缩  
如果没有构建工具，那么我们需要手动的按照某个顺序执行相关的插件进行转化，才能正常的运行在浏览器中。  
**构建工具还做了什么？**
- 模块化开发的支持：虽然浏览器支持esm，但是对于我们从node_modules中的导入他是无法识别的，因为浏览器只能识别性对路径和绝对路径的导入格式。而且构建工具还提供了多种模块化的支持，比如commonjs
- 代码兼容性：比如babel语法降级，sass、less语法转换（这些能力是其他插件提供的，构建工具帮我们集成进来）
- 提高项目性能：压缩文件、代码分割
- 优化开发体验：热更新等

## vite相比于webpack的优势

背景：webpack项目，随着项目越来越大，开发服务器启动时间越来越久，并且热更新也会越来越慢，影响开发体验。  

webpack没法做成vite那样是因为他设计之初就是需要将整个项目打包完成后才启动，并且他天然的支持多种模块化语法，因此在编译阶段需要将各种不同的模块语法转换为webpack内置的模块语法。


- vite服务启动不需要做全量的打包，而webpack需要全量打包完才能启动
- vite处理依赖使用的是esbuild，是用go写的 速度比webpack快
- **按需加载：** vite处理源代码中模块间的依赖是直接交给浏览器去处理 ，速度更快，并且是按需加载，只有用到某个文件才会去加载、解析进行转换
- **充分利用浏览器缓存**：对于npm包的依赖使用强缓存优化（cache-control：max-age：），源码会进行协商缓存

## vite脚手架和vite的区别

vite脚手架就是帮我们集成了vite，并且生成一个模板项目的东西，而vite是一个构建工具  

``` yarn create vite ```

- 首先全局安装create-vite这个对象（就是vite脚手架）
- 其次执行create-vite下bin目录的配置代码，直接从仓库拉取模板文件

## 依赖预购建

vite在开发阶段，项目启动的时候，会对node_modules中的依赖项进行预购建处理，解决了以下问题

- 依赖包的模块语法可以是commonjs、umd等，这些是vite无法限制的，而开发阶段必须使用浏览器兼容的esm，所以vite会对依赖进行转化，统一转换成esm格式，并且存放在.vite/deps/
- 方便路径重写：因为浏览器只能识别相对路径和绝对路径，所以对于源码中对包的引用是找不到的，vite在访问到对应文件的时候，直接对路径进行重写，添加上相应的路径前缀node_modules/.vite/deps/xxx **路径重写是项目启动后的事情**
- 减少网络多包传输：因为依赖包里面还会引入其他的依赖，如果不做处理，会导致浏览器加载一个包的话要发送非常多的请求，esbuild把包里面引入的其他依赖都继承到一个文件里面，让浏览器只发送一个请求

## 开发服务器是怎么识别.vue文件的

首先虽然请求的是.vue文件，但是服务器返回的内容实际上已经是单纯的js内容了，浏览器如何加载内容主要是依据响应头中的content-type来执行的


## vue发布上线后，是如何实现组件按需加载的

https://juejin.cn/post/7200735933054451768  

- 实际上vue根据路由进行每个页面单独的按需加载，其中会先加载依赖项，即页面下又引入的其他模块文件，vite是通过动态创建link标签，并且设置 rel为modulepreload,进行资源的预加载，等所有依赖资源都加载完毕之后，再执行主入口index.vue文件下的js代码，执行具体的逻辑渲染页面。

## vite如何实现样式隔离 

- vite支持使用.module.css的格式开启模块化，这样会给类名添加上唯一的标识防止冲突


## postcss是什么

 postcss可以看做是和babel差不多的工具，只不过babel是处理js，postcss是处理css的

 postcss 主要是可以使用scss、less等进行语法解析，然后补全前缀等兼容旧版浏览器